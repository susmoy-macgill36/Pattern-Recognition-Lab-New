# -*- coding: utf-8 -*-
"""assignment3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J27kY8iHJ1UYO5lv3wd8iStMHKDoeQml

**Assignment 3**

**Name: “Implementing Minimum Error Rate Classifier.”**

**Submitted By:**

**Name: Susmoy Chakraborty**

**ID: 15-02-04-114**

**Section: B**

**Group: B2**

**Submission Date: 11-9-2019**

**IDE: Colab notebook**
"""

#importing all header files

import pandas as pd
import numpy as np
import math
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from sympy import symbols, Eq, solve, simplify

from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

df = pd.read_csv('test.txt', delimiter =",",names =['x','y'])

df

all_classes =[]

for i in range(len(df)):
    all_classes.append(df['x'][i])
    all_classes.append(df['y'][i])

len(all_classes)

all_classes

all_classes_shaped = np.array(all_classes).reshape(len(all_classes) //2,2)

all_classes_shaped

for i in range(len(all_classes_shaped)):
  print(all_classes_shaped[i])

class_1 =[]
class_2 =[]

proba_class_1 = 0.5
proba_class_2 = 0.5

mu_class1 =np.array([0,0])
mu_class2 =np.array([2,2])

upperSigma_class1  = np.array([[0.25,0.3],[0.3,1]])
upperSigma_class2  =np.array([[0.5,0],[0,0.5]])

d=2

'''
f1 = -0.5

f2=(all_classes_shaped[5] - mu_class2 ).T
f3 = np.linalg.inv(upperSigma_class2)

f4 = all_classes_shaped[5] - mu_class2

f5 = (2/2) * math.log(2 * math.pi) 

f6= 0.5* np.log(np.linalg.det(upperSigma_class2))
f7 =math.log(proba_class_2) 


af1 = (f2.dot(f3)).dot(f4)
af2 = f1 * af1
rrt =af2 -f5 -f6 + f7

rrt

'''

g1 =0
g2 =0




for i in range(len(all_classes_shaped)):
  
      g1 =-0.5*(((all_classes_shaped[i] - mu_class1 ).T.dot( np.linalg.inv(upperSigma_class1))).dot(all_classes_shaped[i] - mu_class1))- ((d/2)* np.log(2* math.pi))-(0.5* np.log(np.linalg.det(upperSigma_class1))) + (np.log(proba_class_1))  
      print(g1)
      g2 =-0.5*(((all_classes_shaped[i] - mu_class2 ).T.dot( np.linalg.inv(upperSigma_class2))).dot(all_classes_shaped[i] - mu_class2))- ((d/2)* np.log(2* math.pi))-(0.5* np.log(np.linalg.det(upperSigma_class2))) + (np.log(proba_class_2)) 
      print(g2)
      if (g1>g2):
        class_1.append(all_classes_shaped[i])
      else:
        class_2.append(all_classes_shaped[i])

class_1

class_2

class_1_x =[]
class_1_y =[]

class_2_x =[]

class_2_y =[]

for i in range(len(class_1)):
   
    class_1_x.append(class_1[i][0])
    
    class_1_y.append(class_1[i][1])

for i in range(len(class_2)):
   
    class_2_x.append(class_2[i][0])
    
    class_2_y.append(class_2[i][1])

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')


z =[-1,-1,-1]
z1 =[1,1,1,1,1,1,1,1,1,1]



ax.scatter(class_1_x, class_1_y, z, c='r', marker='o',label='class1')
ax.scatter(class_2_x, class_2_y, z, c='b', marker='*',label='class2')


ax.scatter(class_1_x, class_1_y, pvb,c='r')
ax.scatter(class_2_x, class_2_y, pvb1,c='b')

ax.plot(class_1_x, class_1_y, pvb,c='r')
ax.plot(class_2_x, class_2_y, pvb1,c='b')
#ax.plot_trisurf(class_1_x, class_1_y, pvb)
#ax.plot_trisurf(class_2_x, class_2_y, pvb1)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Probability Density')



plt.legend()
plt.show()

from scipy.stats import multivariate_normal
mvn = multivariate_normal(mu_class1,upperSigma_class1) 
#p = mvn.pdf(class_1[0]) x

pvb =[]
pvb1 =[]

for i in range(len(class_1)):
   
    pvb.append(mvn.pdf(class_1[i])) 
    
for i in range(len(class_2)):
   
    pvb1.append(mvn.pdf(class_2[i]))

pvb

pvb1

np.array(class_1).ndim

x1 = np.linspace(min(all_classes),max(all_classes),50)

x2_temp =np.linspace(min(all_classes),max(all_classes),200)



x2 =[]


for i in range(len(x1)):
  for i1 in range(len(x2_temp)):
    
    a1 = (np.array([x1[i],x2_temp[i1]]).T.dot(np.linalg.inv(upperSigma_class1)-np.linalg.inv(upperSigma_class2))).dot(np.array([x1[i],x2_temp[i1]])) 
    a2 = 2*((np.linalg.inv(upperSigma_class2).dot( mu_class2))- (np.linalg.inv(upperSigma_class1).dot(mu_class1)  )).T.dot(np.array([x1[i],x2_temp[i1]]))
    
    a3 = (mu_class1.T.dot(np.linalg.inv(upperSigma_class1))).dot(mu_class1)
    a4 = (mu_class2.T.dot(np.linalg.inv(upperSigma_class2))).dot(mu_class2)
    a5 = math.log(np.linalg.det(upperSigma_class2)/np.linalg.det(upperSigma_class1))
    a6 =  2* math.log(proba_class_1/proba_class_2)
    
    res = a1 + a2+ a3 -a4 -a5 -a6
    
    if (res <=0.0):
        x2.append(x1[i])
        x2.append(x2_temp[i1])
        break

x2_shaped = np.array(x2).reshape(len(x2)//2,2)

x2_shaped_x =[]

x2_shaped_y =[]

for i in range(len(x2_shaped)):
  x2_shaped_x.append(x2_shaped[i][0])
  x2_shaped_y.append(x2_shaped[i][1])

x2_shaped_y

z_db = -1 * np.ones(29)

len(z_db)

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')


z =[-1,-1,-1]
z1 =[1,1,1,1,1,1,1,1,1,1]



ax.scatter(class_1_x, class_1_y, z, c='r', marker='o',label='class1')
ax.scatter(class_2_x, class_2_y, z, c='b', marker='*',label='class2')


ax.scatter(class_1_x, class_1_y, pvb,c='r')
ax.scatter(class_2_x, class_2_y, pvb1,c='b')

ax.plot(class_1_x, class_1_y, pvb,c='r')
ax.plot(class_2_x, class_2_y, pvb1,c='b')

ax.plot(x2_shaped_x, x2_shaped_y, pvb2,c='g')
#ax.plot_trisurf(class_1_x, class_1_y, pvb)
#ax.plot_trisurf(class_2_x, class_2_y, pvb1)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Probability Density')



plt.legend()
plt.show()

pvb2=[]

for i in range(len(x2_shaped)):
   
    pvb2.append(mvn.pdf(x2_shaped[i]))

len(pvb2)

